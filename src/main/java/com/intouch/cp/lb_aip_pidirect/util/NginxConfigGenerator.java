package com.intouch.cp.lb_aip_pidirect.util;

import com.intouch.cp.lb_aip_pidirect.config.NginxConfig;
import com.intouch.cp.lb_aip_pidirect.model.WeightAllocation;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

import java.time.LocalDateTime;
import java.util.List;

/**
 * Generates NGINX configuration for TRUE weighted round-robin distribution
 * (Not IP-based sticky sessions)
 *
 * Strategy: Proxy chain approach
 * 1. Main server (port 80) → upstream backend
 * 2. Upstream backend → localhost proxies (8081, 8082, etc.)
 * 3. Localhost proxies → actual backends (with different paths)
 */
@Component
@RequiredArgsConstructor
@Slf4j
public class NginxConfigGenerator {

    private final NginxConfig nginxConfig;
    private static final int BASE_PROXY_PORT = 8081;

    /**
     * Generate complete NGINX configuration with round-robin distribution
     */
    public String generateUpstreamConfig(List<WeightAllocation> weights) {
        List<WeightAllocation> activeWeights = weights.stream()
                .filter(WeightAllocation::isActive)
                .toList();

        if (activeWeights.isEmpty()) {
            log.warn("No active servers found. Generating fallback configuration.");
            return generateFallbackConfig();
        }

        StringBuilder config = new StringBuilder();

        // Header
        config.append("# Generated by Dynamic Load Balancer\n");
        config.append("# Generated at: ").append(LocalDateTime.now()).append("\n");
        config.append("# Total servers: ").append(weights.size()).append("\n");
        config.append("# Active servers: ").append(activeWeights.size()).append("\n");
        config.append("# Distribution: TRUE weighted round-robin (not IP-sticky)\n");
        config.append("\n");

        // Calculate total weight
        int totalWeight = activeWeights.stream()
                .mapToInt(WeightAllocation::getWeight)
                .sum();

        // Step 1: Generate backend proxy servers (one per backend)
        config.append("# ============================================\n");
        config.append("# Backend Proxy Servers (localhost forwarding)\n");
        config.append("# ============================================\n\n");

        for (int i = 0; i < activeWeights.size(); i++) {
            WeightAllocation weight = activeWeights.get(i);
            int proxyPort = BASE_PROXY_PORT + i;

            String address = weight.getServerAddress();
            String hostname = extractHostname(address);
            String path = extractPath(address);
            double percentage = (weight.getWeight() * 100.0) / totalWeight;

            config.append("# Proxy for ").append(weight.getServerId())
                    .append(" (").append(String.format("%.1f%%", percentage)).append(")\n");
            config.append("server {\n");
            config.append("    listen 127.0.0.1:").append(proxyPort).append(";\n");
            config.append("    server_name ").append(weight.getServerId()).append(";\n");
            config.append("\n");
            config.append("    location / {\n");
            config.append("        # Forward to actual backend\n");
            config.append("        proxy_pass https://").append(hostname).append(path).append("$request_uri;\n");
//            config.append("\n");
//            config.append("        # SSL settings\n");
//            config.append("        proxy_ssl_server_name on;\n");
//            config.append("        proxy_ssl_name ").append(hostname).append(";\n");
//            config.append("        proxy_ssl_protocols TLSv1.2 TLSv1.3;\n");
            config.append("\n");
            config.append("        # Headers\n");
            config.append("        proxy_set_header Host ").append(hostname).append(";\n");
            config.append("        proxy_set_header X-Real-IP $remote_addr;\n");
            config.append("        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n");
            config.append("        proxy_set_header X-Forwarded-Proto $scheme;\n");
            config.append("\n");
            config.append("        # Timeouts\n");
            config.append("        proxy_connect_timeout 30s;\n");
            config.append("        proxy_send_timeout 30s;\n");
            config.append("        proxy_read_timeout 30s;\n");
            config.append("\n");
            config.append("        proxy_redirect off;\n");
            config.append("        proxy_buffering on;\n");
            config.append("    }\n");
            config.append("}\n\n");

            log.debug("Configured proxy on port {} for {} (weight: {}, {}%)",
                    proxyPort,
                    weight.getServerId(),
                    weight.getWeight(),
                    String.format("%.1f", percentage));
        }

        // Step 2: Generate upstream block pointing to localhost proxies
        config.append("# ============================================\n");
        config.append("# Upstream with Weighted Round-Robin\n");
        config.append("# ============================================\n\n");

        config.append("upstream backend {\n");

        for (int i = 0; i < activeWeights.size(); i++) {
            WeightAllocation weight = activeWeights.get(i);
            int proxyPort = BASE_PROXY_PORT + i;
            int weightValue = weight.getWeight();
            double percentage = (weightValue * 100.0) / totalWeight;

            config.append("    server 127.0.0.1:").append(proxyPort);
            config.append(" weight=").append(weightValue);
            config.append(" max_fails=3 fail_timeout=30s");
            config.append(";  # ").append(weight.getServerId())
                    .append(" - ").append(String.format("%.1f%%", percentage))
                    .append("\n");
        }

        config.append("\n");
        config.append("    # Connection pooling\n");
        config.append("    keepalive 32;\n");
        config.append("}\n");

        return config.toString();
    }

    /**
     * Extract hostname from address (domain only, no path, no port)
     */
    private String extractHostname(String address) {
        String hostname = address;

        if (hostname.contains("://")) {
            hostname = hostname.split("://")[1];
        }

        if (hostname.contains("/")) {
            hostname = hostname.substring(0, hostname.indexOf("/"));
        }

        if (hostname.contains(":")) {
            hostname = hostname.substring(0, hostname.indexOf(":"));
        }

        return hostname;
    }

    /**
     * Extract path from address (path component only)
     */
    private String extractPath(String address) {
        String path = address;

        if (path.contains("://")) {
            path = path.split("://")[1];
        }

        if (path.contains("/")) {
            path = path.substring(path.indexOf("/"));
            if (path.endsWith("/") && path.length() > 1) {
                path = path.substring(0, path.length() - 1);
            }
            return path;
        }

        return "";
    }

    /**
     * Generate fallback configuration when no active servers
     */
    private String generateFallbackConfig() {
        StringBuilder config = new StringBuilder();

        config.append("# FALLBACK CONFIGURATION - No active servers available\n");
        config.append("# Generated at: ").append(LocalDateTime.now()).append("\n");
        config.append("\n");

        config.append("# Fallback upstream\n");
        config.append("upstream backend {\n");
        config.append("    server 127.0.0.1:8080;  # Spring Boot app\n");
        config.append("}\n");

        return config.toString();
    }

    /**
     * Validate generated configuration
     */
    public boolean validateGeneratedConfig(String config) {
        if (config == null || config.trim().isEmpty()) {
            log.error("Generated config is null or empty");
            return false;
        }

        long openBraces = config.chars().filter(ch -> ch == '{').count();
        long closeBraces = config.chars().filter(ch -> ch == '}').count();

        if (openBraces != closeBraces) {
            log.error("Mismatched braces. Open: {}, Close: {}", openBraces, closeBraces);
            return false;
        }

        boolean hasUpstream = config.contains("upstream backend");

        if (!hasUpstream) {
            log.error("Generated config missing upstream directive");
            return false;
        }

        log.debug("Configuration validation passed");
        return true;
    }

    /**
     * Generate configuration summary for logging
     */
    public String generateConfigSummary(List<WeightAllocation> weights) {
        StringBuilder summary = new StringBuilder();

        summary.append("=== NGINX Configuration Summary ===\n");
        summary.append("Generated at: ").append(LocalDateTime.now()).append("\n");
        summary.append("Distribution Mode: Weighted Round-Robin (TRUE load distribution)\n");
        summary.append("Total servers: ").append(weights.size()).append("\n");

        long activeServers = weights.stream().filter(WeightAllocation::isActive).count();
        summary.append("Active servers: ").append(activeServers).append("\n");

        int totalWeight = weights.stream()
                .filter(WeightAllocation::isActive)
                .mapToInt(WeightAllocation::getWeight)
                .sum();
        summary.append("Total weight: ").append(totalWeight).append("\n\n");

        summary.append("Server Details:\n");
        int portNum = BASE_PROXY_PORT;
        for (WeightAllocation weight : weights) {
            if (weight.isActive()) {
                String hostname = extractHostname(weight.getServerAddress());
                String path = extractPath(weight.getServerAddress());
                double percentage = (weight.getWeight() * 100.0) / totalWeight;

                summary.append(String.format("  %s:\n", weight.getServerId()));
                summary.append(String.format("    Backend: %s\n", weight.getServerAddress()));
                summary.append(String.format("    Proxy Port: 127.0.0.1:%d\n", portNum));
                summary.append(String.format("    Host: %s\n", hostname));
                summary.append(String.format("    Path: %s\n", path.isEmpty() ? "(none)" : path));
                summary.append(String.format("    Weight: %d (%.1f%%), Health: %.3f\n",
                        weight.getWeight(),
                        percentage,
                        weight.getHealthScore()));
                portNum++;
            }
        }

        return summary.toString();
    }
}