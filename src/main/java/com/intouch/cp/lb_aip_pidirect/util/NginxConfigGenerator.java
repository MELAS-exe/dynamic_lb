package com.intouch.cp.lb_aip_pidirect.util;

import com.intouch.cp.lb_aip_pidirect.config.NginxConfig;
import com.intouch.cp.lb_aip_pidirect.model.WeightAllocation;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

import java.time.LocalDateTime;
import java.util.List;

/**
 * Generates NGINX configuration for TRUE weighted round-robin distribution
 * with dual upstream support for incoming and outgoing requests
 *
 * Strategy: Proxy chain approach with dual upstreams
 * 1. Main server (port 80) → /incoming → upstream backend_incoming
 * 2. Main server (port 80) → /outgoing → upstream backend_outgoing
 * 3. Each upstream → localhost proxies (8081, 8082, etc. for incoming; 9081, 9082, etc. for outgoing)
 * 4. Localhost proxies → actual backends (with different paths)
 */
@Component
@RequiredArgsConstructor
@Slf4j
public class NginxConfigGenerator {

    private final NginxConfig nginxConfig;
    private static final int BASE_INCOMING_PROXY_PORT = 8081;
    private static final int BASE_OUTGOING_PROXY_PORT = 9081;

    /**
     * Generate complete NGINX configuration with dual upstream (incoming + outgoing)
     */
    public String generateDualUpstreamConfig(List<WeightAllocation> incomingWeights, List<WeightAllocation> outgoingWeights) {
        List<WeightAllocation> activeIncoming = incomingWeights.stream()
                .filter(WeightAllocation::isActive)
                .toList();

        List<WeightAllocation> activeOutgoing = outgoingWeights.stream()
                .filter(WeightAllocation::isActive)
                .toList();

        if (activeIncoming.isEmpty() && activeOutgoing.isEmpty()) {
            log.warn("No active servers found for both incoming and outgoing. Generating fallback configuration.");
            return generateFallbackConfig();
        }

        StringBuilder config = new StringBuilder();

        // Header
        config.append("# Generated by Dynamic Load Balancer - DUAL UPSTREAM CONFIGURATION\n");
        config.append("# Generated at: ").append(LocalDateTime.now()).append("\n");
        config.append("# Incoming servers: ").append(activeIncoming.size()).append("\n");
        config.append("# Outgoing servers: ").append(activeOutgoing.size()).append("\n");
        config.append("# Distribution: TRUE weighted round-robin (not IP-sticky)\n");
        config.append("\n");

        // Generate proxy servers and upstream for INCOMING
        if (!activeIncoming.isEmpty()) {
            config.append(generateProxyServersBlock(activeIncoming, BASE_INCOMING_PROXY_PORT, "INCOMING"));
            config.append(generateUpstreamBlock(activeIncoming, BASE_INCOMING_PROXY_PORT, "backend_incoming", "INCOMING"));
        }

        // Generate proxy servers and upstream for OUTGOING
        if (!activeOutgoing.isEmpty()) {
            config.append(generateProxyServersBlock(activeOutgoing, BASE_OUTGOING_PROXY_PORT, "OUTGOING"));
            config.append(generateUpstreamBlock(activeOutgoing, BASE_OUTGOING_PROXY_PORT, "backend_outgoing", "OUTGOING"));
        }

        return config.toString();
    }

    /**
     * Generate backward-compatible single upstream config (for incoming only)
     * This maintains compatibility with existing single upstream setup
     */
    public String generateUpstreamConfig(List<WeightAllocation> weights) {
        List<WeightAllocation> activeWeights = weights.stream()
                .filter(WeightAllocation::isActive)
                .toList();

        if (activeWeights.isEmpty()) {
            log.warn("No active servers found. Generating fallback configuration.");
            return generateFallbackConfig();
        }

        StringBuilder config = new StringBuilder();

        // Header
        config.append("# Generated by Dynamic Load Balancer\n");
        config.append("# Generated at: ").append(LocalDateTime.now()).append("\n");
        config.append("# Total servers: ").append(activeWeights.size()).append("\n");
        config.append("# Distribution: TRUE weighted round-robin (not IP-sticky)\n");
        config.append("\n");

        // Calculate total weight
        int totalWeight = activeWeights.stream()
                .mapToInt(WeightAllocation::getWeight)
                .sum();

        // Generate backend proxy servers
        config.append("# ============================================\n");
        config.append("# Backend Proxy Servers (localhost forwarding)\n");
        config.append("# ============================================\n\n");

        for (int i = 0; i < activeWeights.size(); i++) {
            WeightAllocation weight = activeWeights.get(i);
            int proxyPort = BASE_INCOMING_PROXY_PORT + i;

            String address = weight.getServerAddress();
            String hostname = extractHostname(address);
            String path = extractPath(address);
            double percentage = (weight.getWeight() * 100.0) / totalWeight;

            config.append("# Proxy for ").append(weight.getServerId())
                    .append(" (").append(String.format("%.1f%%", percentage)).append(")\n");
            config.append("server {\n");
            config.append("    listen 127.0.0.1:").append(proxyPort).append(";\n");
            config.append("    server_name ").append(weight.getServerId()).append(";\n");
            config.append("\n");
            config.append("    location / {\n");
            config.append("        # Forward to actual backend\n");
            config.append("        proxy_pass https://").append(hostname).append(path).append("$request_uri;\n");
            config.append("\n");
            config.append("        # Headers\n");
            config.append("        proxy_set_header Host ").append(hostname).append(";\n");
            config.append("        proxy_set_header X-Real-IP $remote_addr;\n");
            config.append("        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n");
            config.append("        proxy_set_header X-Forwarded-Proto $scheme;\n");
            config.append("\n");
            config.append("        # Timeouts\n");
            config.append("        proxy_connect_timeout 30s;\n");
            config.append("        proxy_send_timeout 30s;\n");
            config.append("        proxy_read_timeout 30s;\n");
            config.append("\n");
            config.append("        proxy_redirect off;\n");
            config.append("        proxy_buffering on;\n");
            config.append("    }\n");
            config.append("}\n\n");
        }

        // Generate upstream block
        config.append("# ============================================\n");
        config.append("# Upstream with Weighted Round-Robin\n");
        config.append("# ============================================\n\n");

        config.append("upstream backend {\n");

        for (int i = 0; i < activeWeights.size(); i++) {
            WeightAllocation weight = activeWeights.get(i);
            int proxyPort = BASE_INCOMING_PROXY_PORT + i;
            int weightValue = weight.getWeight();
            double percentage = (weightValue * 100.0) / totalWeight;

            config.append("    server 127.0.0.1:").append(proxyPort);
            config.append(" weight=").append(weightValue);
            config.append(" max_fails=3 fail_timeout=30s");
            config.append(";  # ").append(weight.getServerId())
                    .append(" - ").append(String.format("%.1f%%", percentage))
                    .append("\n");
        }

        config.append("\n");
        config.append("    # Connection pooling\n");
        config.append("    keepalive 32;\n");
        config.append("}\n");

        return config.toString();
    }

    /**
     * Generate proxy servers block for a set of weights
     */
    private String generateProxyServersBlock(List<WeightAllocation> weights, int basePort, String type) {
        StringBuilder config = new StringBuilder();

        int totalWeight = weights.stream()
                .mapToInt(WeightAllocation::getWeight)
                .sum();

        config.append("# ============================================\n");
        config.append("# ").append(type).append(" Backend Proxy Servers\n");
        config.append("# ============================================\n\n");

        for (int i = 0; i < weights.size(); i++) {
            WeightAllocation weight = weights.get(i);
            int proxyPort = basePort + i;

            String address = weight.getServerAddress();
            String hostname = extractHostname(address);
            String path = extractPath(address);
            double percentage = (weight.getWeight() * 100.0) / totalWeight;

            config.append("# ").append(type).append(" Proxy for ").append(weight.getServerId())
                    .append(" (").append(String.format("%.1f%%", percentage)).append(")\n");
            config.append("server {\n");
            config.append("    listen 127.0.0.1:").append(proxyPort).append(";\n");
            config.append("    server_name ").append(weight.getServerId()).append(";\n");
            config.append("\n");
            config.append("    location / {\n");
            config.append("        # Forward to actual backend\n");
            config.append("        proxy_pass https://").append(hostname).append(path).append("$request_uri;\n");
            config.append("\n");
            config.append("        # Headers\n");
            config.append("        proxy_set_header Host ").append(hostname).append(";\n");
            config.append("        proxy_set_header X-Real-IP $remote_addr;\n");
            config.append("        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n");
            config.append("        proxy_set_header X-Forwarded-Proto $scheme;\n");
            config.append("\n");
            config.append("        # Timeouts\n");
            config.append("        proxy_connect_timeout 30s;\n");
            config.append("        proxy_send_timeout 30s;\n");
            config.append("        proxy_read_timeout 30s;\n");
            config.append("\n");
            config.append("        proxy_redirect off;\n");
            config.append("        proxy_buffering on;\n");
            config.append("    }\n");
            config.append("}\n\n");
        }

        return config.toString();
    }

    /**
     * Generate upstream block for a set of proxy servers
     */
    private String generateUpstreamBlock(List<WeightAllocation> weights, int basePort, String upstreamName, String type) {
        StringBuilder config = new StringBuilder();

        int totalWeight = weights.stream()
                .mapToInt(WeightAllocation::getWeight)
                .sum();

        config.append("# ============================================\n");
        config.append("# ").append(type).append(" Upstream with Weighted Round-Robin\n");
        config.append("# ============================================\n\n");

        config.append("upstream ").append(upstreamName).append(" {\n");

        for (int i = 0; i < weights.size(); i++) {
            WeightAllocation weight = weights.get(i);
            int proxyPort = basePort + i;
            int weightValue = weight.getWeight();
            double percentage = (weightValue * 100.0) / totalWeight;

            config.append("    server 127.0.0.1:").append(proxyPort);
            config.append(" weight=").append(weightValue);
            config.append(" max_fails=3 fail_timeout=30s");
            config.append(";  # ").append(weight.getServerId())
                    .append(" - ").append(String.format("%.1f%%", percentage))
                    .append("\n");
        }

        config.append("\n");
        config.append("    # Connection pooling\n");
        config.append("    keepalive 32;\n");
        config.append("}\n\n");

        return config.toString();
    }

    /**
     * Generate fallback configuration when no servers are active
     */
    private String generateFallbackConfig() {
        StringBuilder config = new StringBuilder();
        config.append("# Fallback configuration - no active servers\n");
        config.append("# Generated at: ").append(LocalDateTime.now()).append("\n\n");

        config.append("upstream backend {\n");
        config.append("    server 127.0.0.1:8080;  # Fallback placeholder\n");
        config.append("}\n\n");

        config.append("upstream backend_incoming {\n");
        config.append("    server 127.0.0.1:8080;  # Fallback placeholder\n");
        config.append("}\n\n");

        config.append("upstream backend_outgoing {\n");
        config.append("    server 127.0.0.1:8080;  # Fallback placeholder\n");
        config.append("}\n");

        return config.toString();
    }

    /**
     * Extract hostname from address (domain only, no path, no port)
     */
    private String extractHostname(String address) {
        String hostname = address;

        if (hostname.contains("://")) {
            hostname = hostname.split("://")[1];
        }

        if (hostname.contains("/")) {
            hostname = hostname.substring(0, hostname.indexOf("/"));
        }

        if (hostname.contains(":")) {
            hostname = hostname.substring(0, hostname.indexOf(":"));
        }

        return hostname;
    }

    /**
     * Extract path from address (everything after domain, including leading /)
     */
    private String extractPath(String address) {
        if (address.contains("://")) {
            address = address.split("://")[1];
        }

        if (address.contains("/")) {
            return "/" + address.substring(address.indexOf("/") + 1);
        }

        return "";
    }

    /**
     * Validate generated configuration
     */
    public boolean validateConfig(String config) {
        if (config == null || config.trim().isEmpty()) {
            log.error("Configuration is null or empty");
            return false;
        }

        long openBraces = config.chars().filter(ch -> ch == '{').count();
        long closeBraces = config.chars().filter(ch -> ch == '}').count();

        if (openBraces != closeBraces) {
            log.error("Mismatched braces in configuration. Open: {}, Close: {}", openBraces, closeBraces);
            return false;
        }

        boolean hasUpstream = config.contains("upstream backend") ||
                config.contains("upstream backend_incoming") ||
                config.contains("upstream backend_outgoing");

        if (!hasUpstream) {
            log.error("Generated config missing upstream directive");
            return false;
        }

        log.debug("Configuration validation passed");
        return true;
    }

    /**
     * Generate configuration summary for logging
     */
    public String generateConfigSummary(List<WeightAllocation> incomingWeights, List<WeightAllocation> outgoingWeights) {
        StringBuilder summary = new StringBuilder();

        summary.append("=== NGINX DUAL UPSTREAM Configuration Summary ===\n");
        summary.append("Generated at: ").append(LocalDateTime.now()).append("\n");
        summary.append("Distribution Mode: Weighted Round-Robin (TRUE load distribution)\n\n");

        // Incoming summary
        summary.append("--- INCOMING SERVERS ---\n");
        summary.append(generateServerGroupSummary(incomingWeights, BASE_INCOMING_PROXY_PORT));

        // Outgoing summary
        summary.append("\n--- OUTGOING SERVERS ---\n");
        summary.append(generateServerGroupSummary(outgoingWeights, BASE_OUTGOING_PROXY_PORT));

        return summary.toString();
    }

    /**
     * Generate summary for a single server group
     */
    private String generateServerGroupSummary(List<WeightAllocation> weights, int basePort) {
        StringBuilder summary = new StringBuilder();

        long activeServers = weights.stream().filter(WeightAllocation::isActive).count();
        summary.append("Total servers: ").append(weights.size()).append("\n");
        summary.append("Active servers: ").append(activeServers).append("\n");

        if (activeServers == 0) {
            summary.append("No active servers in this group\n");
            return summary.toString();
        }

        int totalWeight = weights.stream()
                .filter(WeightAllocation::isActive)
                .mapToInt(WeightAllocation::getWeight)
                .sum();
        summary.append("Total weight: ").append(totalWeight).append("\n\n");

        summary.append("Server Details:\n");
        int portNum = basePort;
        for (WeightAllocation weight : weights) {
            if (weight.isActive()) {
                String hostname = extractHostname(weight.getServerAddress());
                String path = extractPath(weight.getServerAddress());
                double percentage = (weight.getWeight() * 100.0) / totalWeight;

                summary.append(String.format("  %s:\n", weight.getServerId()));
                summary.append(String.format("    Backend: %s\n", weight.getServerAddress()));
                summary.append(String.format("    Proxy Port: 127.0.0.1:%d\n", portNum));
                summary.append(String.format("    Host: %s\n", hostname));
                summary.append(String.format("    Path: %s\n", path.isEmpty() ? "(none)" : path));
                summary.append(String.format("    Weight: %d (%.1f%%), Health: %.3f\n",
                        weight.getWeight(),
                        percentage,
                        weight.getHealthScore()));
                portNum++;
            }
        }

        return summary.toString();
    }
}