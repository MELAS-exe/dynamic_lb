package com.intouch.cp.lb_aip_pidirect.util;

import com.intouch.cp.lb_aip_pidirect.config.NginxConfig;
import com.intouch.cp.lb_aip_pidirect.model.WeightAllocation;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.util.List;

@Component
@RequiredArgsConstructor
@Slf4j
public class NginxConfigGenerator {

    private final NginxConfig nginxConfig;

    public String generateUpstreamConfig(List<WeightAllocation> weights) {
        StringBuilder config = new StringBuilder();

        // Header comment
        config.append("# Generated by Dynamic Load Balancer for Cloud Run\n");
        config.append("# Generated at: ").append(LocalDateTime.now()).append("\n");
        config.append("# Total servers: ").append(weights.size()).append("\n");
        config.append("# Active servers: ").append(weights.stream().mapToInt(w -> w.isActive() ? 1 : 0).sum()).append("\n");
        config.append("\n");

        // Calculate total weight for active servers
        int totalWeight = weights.stream()
                .filter(WeightAllocation::isActive)
                .mapToInt(WeightAllocation::getWeight)
                .sum();

        if (totalWeight == 0) {
            log.warn("No active servers with weight > 0");
            // Create a default upstream to prevent errors
            config.append("upstream ").append(nginxConfig.getNginx().getUpstreamName()).append(" {\n");
            config.append("    server 127.0.0.1:8080;\n");
            config.append("}\n\n");
            config.append("# No active backends - defaulting to localhost\n");
            config.append("map $uri $backend_server { default 127.0.0.1:8080; }\n");
            config.append("map $uri $backend_host { default localhost; }\n");
            return config.toString();
        }

        // Generate split_clients configuration for weighted load balancing
        config.append("# Weighted backend selection based on client IP and request\n");
        config.append("split_clients \"${remote_addr}${request_uri}\" $backend_server {\n");

        double cumulativePercent = 0.0;
        List<WeightAllocation> activeWeights = weights.stream()
                .filter(WeightAllocation::isActive)
                .toList();

        for (int i = 0; i < activeWeights.size(); i++) {
            WeightAllocation weight = activeWeights.get(i);
            double percentage = (weight.getWeight() * 100.0) / totalWeight;

            if (i == activeWeights.size() - 1) {
                // Last server gets the remainder (100% - cumulative)
                config.append("    *                ").append(weight.getServerAddress())
                        .append("max-fails=3")
                        .append("fail_timeout=30s")
                        .append(";  # ").append(weight.getServerId())
                        .append(" - Health: ").append(String.format("%.3f", weight.getHealthScore()))
                        .append("\n");
            } else {
                cumulativePercent += percentage;
                config.append("    ").append(String.format("%.2f%%", cumulativePercent))
                        .append("           ").append(weight.getServerAddress())
                        .append("max-fails=3")
                        .append("fail_timeout=30s")
                        .append(";  # ").append(weight.getServerId())
                        .append(" - Weight: ").append(weight.getWeight())
                        .append("\n");
            }
        }

        config.append("}\n\n");

        // Extract hostname from backend_server for Host header
        config.append("# Extract hostname from selected backend for Host header\n");
        config.append("map $backend_server $backend_host {\n");
        for (WeightAllocation weight : activeWeights) {
            String address = weight.getServerAddress();
            String hostname = address.contains(":") ? address.split(":")[0] : address;
            config.append("    ").append(address).append("    ").append(hostname).append(";\n");
        }
        config.append("    default              $backend_server;\n");
        config.append("}\n");

        return config.toString();
    }

    public String generateCompleteNginxConfig(List<WeightAllocation> weights) {
        StringBuilder config = new StringBuilder();

        // Load template if exists
        String template = loadTemplate();
        if (template != null) {
            config.append(template);
            // Replace placeholder in template
            String upstreamBlock = generateUpstreamConfig(weights);
            config = new StringBuilder(template.replace("{{UPSTREAM_BLOCK}}", upstreamBlock));
        } else {
            // Generate basic config
            config.append(generateBasicNginxConfig(weights));
        }

        return config.toString();
    }

    private String loadTemplate() {
        try {
            String templatePath = nginxConfig.getNginx().getTemplatePath();
            if (templatePath != null) {
                Path path = Paths.get(templatePath);
                if (Files.exists(path)) {
                    return Files.readString(path);
                }
            }
        } catch (IOException e) {
            log.warn("Could not load template: {}", e.getMessage());
        }
        return null;
    }

    private String generateBasicNginxConfig(List<WeightAllocation> weights) {
        StringBuilder config = new StringBuilder();

        config.append("# Basic NGINX configuration with dynamic upstream\n");
        config.append("# Generated by Dynamic Load Balancer at ").append(LocalDateTime.now()).append("\n\n");

        // Events block
        config.append("events {\n");
        config.append("    worker_connections 1024;\n");
        config.append("}\n\n");

        // HTTP block
        config.append("http {\n");
        config.append("    include       /etc/nginx/mime.types;\n");
        config.append("    default_type  application/octet-stream;\n\n");

        // Logging
        config.append("    # Logging\n");
        config.append("    log_format main '$remote_addr - $remote_user [$time_local] \"$request\" '\n");
        config.append("                    '$status $body_bytes_sent \"$http_referer\" '\n");
        config.append("                    '\"$http_user_agent\" \"$http_x_forwarded_for\" '\n");
        config.append("                    'upstream_addr=$upstream_addr '\n");
        config.append("                    'upstream_status=$upstream_status '\n");
        config.append("                    'upstream_response_time=$upstream_response_time';\n\n");

        config.append("    access_log /var/log/nginx/access.log main;\n");
        config.append("    error_log /var/log/nginx/error.log;\n\n");

        // Basic settings
        config.append("    # Basic settings\n");
        config.append("    sendfile on;\n");
        config.append("    tcp_nopush on;\n");
        config.append("    tcp_nodelay on;\n");
        config.append("    keepalive_timeout 65;\n");
        config.append("    types_hash_max_size 2048;\n\n");

        // Gzip
        config.append("    # Gzip compression\n");
        config.append("    gzip on;\n");
        config.append("    gzip_vary on;\n");
        config.append("    gzip_min_length 1024;\n");
        config.append("    gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;\n\n");

        // Upstream block
        config.append("    # Dynamic upstream block\n");
        config.append("    ").append(generateUpstreamConfig(weights).replace("\n", "\n    ")).append("\n");

        // Server block
        config.append("    # Main server block\n");
        config.append("    server {\n");
        config.append("        listen 80;\n");
        config.append("        server_name _;\n\n");

        config.append("        # Health check endpoint\n");
        config.append("        location /health {\n");
        config.append("            access_log off;\n");
        config.append("            return 200 \"healthy\\n\";\n");
        config.append("            add_header Content-Type text/plain;\n");
        config.append("        }\n\n");

        config.append("        # Load balancer status\n");
        config.append("        location /nginx_status {\n");
        config.append("            stub_status on;\n");
        config.append("            access_log off;\n");
        config.append("            allow 127.0.0.1;\n");
        config.append("            deny all;\n");
        config.append("        }\n\n");

        config.append("        # Proxy to backend\n");
        config.append("        location / {\n");
        config.append("            proxy_pass http://").append(nginxConfig.getNginx().getUpstreamName()).append(";\n");
        config.append("            proxy_set_header Host $host;\n");
        config.append("            proxy_set_header X-Real-IP $remote_addr;\n");
        config.append("            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n");
        config.append("            proxy_set_header X-Forwarded-Proto $scheme;\n");
        config.append("            proxy_connect_timeout 30s;\n");
        config.append("            proxy_send_timeout 30s;\n");
        config.append("            proxy_read_timeout 30s;\n");
        config.append("            proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504;\n");
        config.append("        }\n");
        config.append("    }\n");
        config.append("}\n");

        return config.toString();
    }

    public String generateUpstreamHealthCheck(List<WeightAllocation> weights) {
        StringBuilder config = new StringBuilder();

        config.append("# Health check configuration for NGINX Plus\n");
        config.append("# Add this to your server block if using NGINX Plus\n\n");

        for (WeightAllocation weight : weights) {
            if (weight.isActive()) {
                config.append("# Health check for ").append(weight.getServerId()).append("\n");
                config.append("location /health_check_").append(weight.getServerId()).append(" {\n");
                config.append("    internal;\n");
                config.append("    proxy_pass ").append("http://").append(weight.getServerAddress()).append("/health;\n");
                config.append("    proxy_connect_timeout 2s;\n");
                config.append("    proxy_read_timeout 2s;\n");
                config.append("}\n\n");
            }
        }

        return config.toString();
    }

    public boolean validateGeneratedConfig(String config) {
        if (config == null || config.trim().isEmpty()) {
            log.error("Generated config is null or empty");
            return false;
        }

        // Basic syntax validation
        long openBraces = config.chars().filter(ch -> ch == '{').count();
        long closeBraces = config.chars().filter(ch -> ch == '}').count();

        if (openBraces != closeBraces) {
            log.error("Mismatched braces in generated config. Open: {}, Close: {}", openBraces, closeBraces);
            return false;
        }

        // Check for required elements
        if (!config.contains("upstream")) {
            log.error("Generated config missing upstream block");
            return false;
        }

        if (!config.contains("server ")) {
            log.error("Generated config missing server definitions");
            return false;
        }

        // Check for valid upstream name
        if (!config.contains(nginxConfig.getNginx().getUpstreamName())) {
            log.error("Generated config missing configured upstream name: {}",
                    nginxConfig.getNginx().getUpstreamName());
            return false;
        }

        log.debug("Generated config validation passed");
        return true;
    }

    public String generateConfigSummary(List<WeightAllocation> weights) {
        StringBuilder summary = new StringBuilder();

        summary.append("=== NGINX Configuration Summary ===\n");
        summary.append("Generated at: ").append(LocalDateTime.now()).append("\n");
        summary.append("Upstream name: ").append(nginxConfig.getNginx().getUpstreamName()).append("\n");
        summary.append("Total servers: ").append(weights.size()).append("\n");

        long activeServers = weights.stream().filter(WeightAllocation::isActive).count();
        summary.append("Active servers: ").append(activeServers).append("\n");
        summary.append("Inactive servers: ").append(weights.size() - activeServers).append("\n");

        int totalWeight = weights.stream()
                .filter(WeightAllocation::isActive)
                .mapToInt(WeightAllocation::getWeight)
                .sum();
        summary.append("Total weight: ").append(totalWeight).append("\n\n");

        summary.append("Server Details:\n");
        for (WeightAllocation weight : weights) {
            summary.append(String.format("  %s (%s): weight=%d, health=%.3f, status=%s\n",
                    weight.getServerId(),
                    weight.getServerAddress(),
                    weight.getWeight(),
                    weight.getHealthScore(),
                    weight.isActive() ? "ACTIVE" : "INACTIVE"
            ));
        }

        return summary.toString();
    }
}