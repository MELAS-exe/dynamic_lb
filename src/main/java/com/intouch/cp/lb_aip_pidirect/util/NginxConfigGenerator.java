package com.intouch.cp.lb_aip_pidirect.util;

import com.intouch.cp.lb_aip_pidirect.config.NginxConfig;
import com.intouch.cp.lb_aip_pidirect.model.WeightAllocation;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.util.List;
import java.util.stream.Collectors;

@Component
@RequiredArgsConstructor
@Slf4j
public class NginxConfigGenerator {

    private final NginxConfig nginxConfig;

    public String generateUpstreamConfig(List<WeightAllocation> weights) {
        StringBuilder config = new StringBuilder();

        // Header comment
        config.append("# Generated by Dynamic Load Balancer for Cloud Run\n");
        config.append("# Generated at: ").append(LocalDateTime.now()).append("\n");
        config.append("# Total servers: ").append(weights.size()).append("\n");
        config.append("# Active servers: ").append(weights.stream().filter(WeightAllocation::isActive).count()).append("\n");
        config.append("\n");

        // Filter active servers
        List<WeightAllocation> activeWeights = weights.stream()
                .filter(WeightAllocation::isActive)
                .collect(Collectors.toList());

        // Calculate total weight for active servers
        int totalWeight = activeWeights.stream()
                .mapToInt(WeightAllocation::getWeight)
                .sum();

        if (totalWeight == 0 || activeWeights.isEmpty()) {
            log.warn("No active servers with weight > 0. Generating fallback configuration.");
            return generateFallbackConfig();
        }

        // Generate split_clients configuration for weighted load balancing
        config.append("split_clients \"${remote_addr}${request_uri}\" $backend_server {\n");

        double cumulativePercentage = 0.0;
        for (int i = 0; i < activeWeights.size(); i++) {
            WeightAllocation weight = activeWeights.get(i);
            double percentage = (weight.getWeight() * 100.0) / totalWeight;
            cumulativePercentage += percentage;

            // Format percentage with 2 decimal places
            String percentageStr = String.format("%.2f%%",
                    i == activeWeights.size() - 1 ? 100.0 : cumulativePercentage);

            String serverAddress = weight.getServerAddress();
            config.append("    ").append(percentageStr)
                    .append("    ").append(serverAddress).append(";\n");

            log.debug("Server {} allocated {}% (cumulative: {}%)",
                    weight.getServerId(),
                    String.format("%.2f", percentage),
                    String.format("%.2f", cumulativePercentage));
        }

        config.append("}\n\n");

        // Generate map for backend hostnames
        config.append("map $backend_server $backend_host {\n");
        for (WeightAllocation weight : activeWeights) {
            String address = weight.getServerAddress();
            // Extract hostname from URL (remove protocol and path)
            String hostname = address.contains("://") ?
                    address.split("://")[1].split("/")[0].split(":")[0] :
                    address.split(":")[0];
            config.append("    ").append(address)
                    .append("    ").append(hostname).append(";\n");
        }
        config.append("    default              $backend_server;\n");
        config.append("}\n");

        return config.toString();
    }

    private String generateFallbackConfig() {
        StringBuilder config = new StringBuilder();

        config.append("# FALLBACK CONFIGURATION - No active servers available\n");
        config.append("# Generated at: ").append(LocalDateTime.now()).append("\n");
        config.append("\n");
        config.append("# Default to localhost to prevent NGINX errors\n");
        config.append("split_clients \"${remote_addr}${request_uri}\" $backend_server {\n");
        config.append("    100%    127.0.0.1:8080;\n");
        config.append("}\n\n");
        config.append("map $backend_server $backend_host {\n");
        config.append("    127.0.0.1:8080    localhost;\n");
        config.append("    default           localhost;\n");
        config.append("}\n");

        return config.toString();
    }

    public String generateCompleteNginxConfig(List<WeightAllocation> weights) {
        StringBuilder config = new StringBuilder();

        // Load template if exists
        String template = loadTemplate();
        if (template != null) {
            config.append(template);
            // Replace placeholder in template
            String upstreamBlock = generateUpstreamConfig(weights);
            config = new StringBuilder(template.replace("{{UPSTREAM_BLOCK}}", upstreamBlock));
        } else {
            // Generate basic config
            config.append(generateBasicNginxConfig(weights));
        }

        return config.toString();
    }

    private String loadTemplate() {
        try {
            String templatePath = nginxConfig.getNginx().getTemplatePath();
            if (templatePath != null) {
                Path path = Paths.get(templatePath);
                if (Files.exists(path)) {
                    return Files.readString(path);
                }
            }
        } catch (IOException e) {
            log.warn("Could not load template: {}", e.getMessage());
        }
        return null;
    }

    private String generateBasicNginxConfig(List<WeightAllocation> weights) {
        StringBuilder config = new StringBuilder();

        config.append("# Basic NGINX configuration with dynamic upstream\n");
        config.append("# Generated by Dynamic Load Balancer at ").append(LocalDateTime.now()).append("\n\n");

        // Events block
        config.append("events {\n");
        config.append("    worker_connections 1024;\n");
        config.append("}\n\n");

        // HTTP block
        config.append("http {\n");
        config.append("    # Dynamic upstream block\n");
        config.append("    ").append(generateUpstreamConfig(weights).replace("\n", "\n    ")).append("\n");

        // Server block
        config.append("    # Main server block\n");
        config.append("    server {\n");
        config.append("        listen 80;\n");
        config.append("        server_name _;\n\n");

        config.append("        # Health check endpoint\n");
        config.append("        location /health {\n");
        config.append("            access_log off;\n");
        config.append("            return 200 \"healthy\\n\";\n");
        config.append("            add_header Content-Type text/plain;\n");
        config.append("        }\n\n");

        config.append("        # Load balancer status\n");
        config.append("        location /nginx_status {\n");
        config.append("            stub_status on;\n");
        config.append("            access_log off;\n");
        config.append("            allow 127.0.0.1;\n");
        config.append("            deny all;\n");
        config.append("        }\n\n");

        config.append("        # Proxy to backend\n");
        config.append("        location / {\n");
        config.append("            proxy_pass http://$backend_server;\n");
        config.append("            proxy_set_header Host $backend_host;\n");
        config.append("            proxy_set_header X-Real-IP $remote_addr;\n");
        config.append("            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n");
        config.append("            proxy_set_header X-Forwarded-Proto $scheme;\n");
        config.append("            proxy_connect_timeout 30s;\n");
        config.append("            proxy_send_timeout 30s;\n");
        config.append("            proxy_read_timeout 30s;\n");
        config.append("            proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504;\n");
        config.append("        }\n");
        config.append("    }\n");
        config.append("}\n");

        return config.toString();
    }

    public String generateUpstreamHealthCheck(List<WeightAllocation> weights) {
        StringBuilder config = new StringBuilder();

        config.append("# Health check configuration for NGINX Plus\n");
        config.append("# Add this to your server block if using NGINX Plus\n\n");

        for (WeightAllocation weight : weights) {
            if (weight.isActive()) {
                config.append("# Health check for ").append(weight.getServerId()).append("\n");
                config.append("location /health_check_").append(weight.getServerId()).append(" {\n");
                config.append("    internal;\n");
                config.append("    proxy_pass ").append("http://").append(weight.getServerAddress()).append("/health;\n");
                config.append("    proxy_connect_timeout 2s;\n");
                config.append("    proxy_read_timeout 2s;\n");
                config.append("}\n\n");
            }
        }

        return config.toString();
    }

    public boolean validateGeneratedConfig(String config) {
        if (config == null || config.trim().isEmpty()) {
            log.error("Generated config is null or empty");
            return false;
        }

        // Basic syntax validation - check for balanced braces
        long openBraces = config.chars().filter(ch -> ch == '{').count();
        long closeBraces = config.chars().filter(ch -> ch == '}').count();

        if (openBraces != closeBraces) {
            log.error("Mismatched braces in generated config. Open: {}, Close: {}", openBraces, closeBraces);
            return false;
        }

        // Check for required elements in split_clients configuration
        boolean hasSplitClients = config.contains("split_clients");
        boolean hasBackendServer = config.contains("$backend_server");
        boolean hasMap = config.contains("map");
        boolean hasBackendHost = config.contains("$backend_host");

        if (!hasSplitClients) {
            log.error("Generated config missing split_clients directive");
            return false;
        }

        if (!hasBackendServer) {
            log.error("Generated config missing $backend_server variable");
            return false;
        }

        if (!hasMap) {
            log.error("Generated config missing map directive");
            return false;
        }

        if (!hasBackendHost) {
            log.error("Generated config missing $backend_host variable");
            return false;
        }

        // Check for valid percentage values in split_clients
        if (config.contains("split_clients")) {
            boolean hasPercentage = config.matches("(?s).*\\d+(\\.\\d+)?%.*");
            if (!hasPercentage) {
                log.error("Generated config missing percentage values in split_clients");
                return false;
            }
        }

        // Check that there's at least one server address
        // Look for patterns like "50.00%    https://example.com;"
        boolean hasServerAddress = config.matches("(?s).*\\d+(\\.\\d+)?%\\s+\\S+;.*");
        if (!hasServerAddress) {
            log.error("Generated config missing server addresses in split_clients block");
            return false;
        }

        log.debug("Generated config validation passed");
        log.debug("Config preview: {}", config.substring(0, Math.min(300, config.length())));
        return true;
    }

    public String generateConfigSummary(List<WeightAllocation> weights) {
        StringBuilder summary = new StringBuilder();

        summary.append("=== NGINX Configuration Summary ===\n");
        summary.append("Generated at: ").append(LocalDateTime.now()).append("\n");
        summary.append("Upstream name: ").append(nginxConfig.getNginx().getUpstreamName()).append("\n");
        summary.append("Total servers: ").append(weights.size()).append("\n");

        long activeServers = weights.stream().filter(WeightAllocation::isActive).count();
        summary.append("Active servers: ").append(activeServers).append("\n");
        summary.append("Inactive servers: ").append(weights.size() - activeServers).append("\n");

        int totalWeight = weights.stream()
                .filter(WeightAllocation::isActive)
                .mapToInt(WeightAllocation::getWeight)
                .sum();
        summary.append("Total weight: ").append(totalWeight).append("\n\n");

        summary.append("Server Details:\n");
        for (WeightAllocation weight : weights) {
            summary.append(String.format("  %s (%s): weight=%d, health=%.3f, status=%s\n",
                    weight.getServerId(),
                    weight.getServerAddress(),
                    weight.getWeight(),
                    weight.getHealthScore(),
                    weight.isActive() ? "ACTIVE" : "INACTIVE"
            ));
        }

        return summary.toString();
    }
}